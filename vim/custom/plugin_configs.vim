runtime! macros/matchit.vim                           " Find matching ( ), [ ], { } and def/end

" indent guide config - assumes colorscheme passed from terminal
let g:indent_guides_auto_colors = 0
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=black ctermbg=0
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=black ctermbg=6
let g:indent_guides_start_level = 3
let g:indent_guides_guide_size = 1

filetype plugin on                                    " enable ctag plugin
set tags+=gems.tags                                   " add gems.tags (generated by guard-ctags-bundler) to list of inspected ctags

" git gutter
let g:gitgutter_sign_column_always = 1

" setup CtrlP
let g:ctrlp_working_path_mode = 'r'
set wildignore+=*/tmp/*,*.so,*.swp,*.zip
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/]\.(git|hg|svn)$',
  \ 'file': '\v\.(exe|so|dll)$',
  \ }

" The Silver Searcher
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor\ --ignore-dir\ tags\ --ignore-dir\ log\ --ignore-dir\ gems.tags\ --ignore-dir\ tmp

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor --ignore-dir gems.tags --ignore-dir tmp --ignore-dir log -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

" bind K to grep word under cursor
nnoremap K :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

" bind \ (backward slash) to grep shortcut
command -nargs=+ -complete=file -bar Ag silent! grep! --ignore gems.tags --ignore log --ignore tags --ignore tmp <args>|cwindow|redraw!

nnoremap \ :Ag<SPACE>

" setup startify bookmarks
" let g:startify_bookmarks = [ '~/.vimrc', '~/.bashrc' ]
"
" set git gutter to always leave the gutter open, to prevent shifting
let g:gitgutter_sign_column_always = 1

" set options for buftabline
" let g:buftabline_numbers = 1
" let g:buftabline_indicators = 1
" let g:buftabline_separators = 1

" config bufferline
let g:bufferline_echo = 0
let g:bufferline_rotate = 0

autocmd VimEnter *
  \ let &statusline='%{bufferline#refresh_status()}'
  \ .bufferline#get_status_string()
